Modulo Programación Orientada a Objetos

***Clase 1 Lo que aprenderás sobre programación orientada a objetos y algoritmos con Python***
Objetivos

- Entender cómo funciona la programación orientada a objetos
- Entender como medir la eficiencia temporal y espacial de nuestros algoritmos
- Entender cómo y por qué graficar
- Aprender a resolver problemas de búsqueda, ordenación y optimización

***Clase 2 Programación Orientada a Objetos***

Programación orientada a objetos en Python
Uno de los elementos más importantes de los lenguajes de programación es la utilización de clases para organizar programas en módulos y abstracciones de datos.

Las clases se pueden utilizar de diversas maneras. Pero en este artículo hablaremos de cómo utilizarlas en el contexto de la programación orientada a objetos. La clave para entender la programación orientada a objetos es pensar en objetos como agrupaciones de datos y los métodos que operan en dichos datos.

Por ejemplo, podemos representar a una persona con propiedades como nombre, edad, género, etc. y los comportamientos de dicha persona como caminar, cantar, comer, etc. De la misma manera podemos representar unos audífonos con propiedades como su marca, tamaño, color, etc. y sus comportamientos como reproducir música, pausar y avanzar a la siguiente canción.

Puesto de otra manera, la programación orientada a objetos nos permite modelar cosas reales y concretas del mundo y sus relaciones con otros objetos.

Las ideas detrás de la programación orientada a objetos tienen más de 50 años y han sido ampliamente aceptadas y practicadas en los últimos treinta. A mediados de la década de los setenta se comenzaron a escribir artículos académicos explicando los beneficios de esta aproximación a la programación. También durante esos años se comenzaron a escribir los primeros lenguajes de programación que incorporaban estas ideas (como Smalltalk y CLU). Pero no fue hasta la llegada de Java y C++ que la idea consiguió un número importante de seguidores.

Hasta ahora, en el curso previo de esta serie hemos utilizado programación orientada a objetos de manera implícita. Cuando decimos “Los objetos son las principales cosas que un programa de Python manipula. Cada objeto tiene un tipo que define qué cosas puede realizar un programa con dicho objeto,” nos estamos refiriendo a las ideas principales de la programación orientada a objetos. Hemos utilizado los tipos lista y
diccionario, entre muchos otros, así como los métodos asociados a dichos tipos.

Así como los creadores de un lenguaje de programación solo pueden diseñar una fracción muy pequeña de todas las funciones útiles (como abs, float, type, etc.), también pueden escribir una fracción muy pequeña de los tipos útiles (int, str, dict, list, etc.). Ya sabemos los mecanismos que nos permiten crear funciones, ahora veremos los mecanismos que nos permiten crear nuevos tipos (o clases).

Clases en Python
Las estructuras primitivas con las que hemos trabajado hasta ahora nos permiten definir cosas sencillas, como el costo de algo, el nombre de un usuario, las veces que debe correr un bucle, etc. Sin embargo, existen ocasiones cuando necesitamos definir estructuras más complejas, por ejemplo un hotel. Podríamos utilizar dos listas: una para definir los cuartos y una segunda para definir si el cuarto se encuentra ocupado o no.

cuartos_de_hotel = [101, 102, 103, 201, 202, 203]
cuarto_ocupado = [True, False, False, True, True, False]
Sin embargo, este tipo de organización rápidamente se sale de control. ¿Qué tal que quisiéramos añadir más propiedades, cómo si el cuarto ya fue aseado o no? ¿Si el cuarto tiene cama doble o sencilla? Esto nos lleva a una falta fuerte de organización y es justamente el punto que justifica la existencia de clases.

Las clases nos permiten crear nuevos tipos que contiene información arbitraria sobre un objeto. En el caso del hotel, podríamos crear dos clases Hotel() y Cuarto() que nos permitiera dar seguimiento a las propiedades como número de cuartos, ocupación, aseo, tipo de habitación, etc.

Es importante resaltar que las clases solo proveen estructura. Son un molde con el cual podemos construir objetos específicos. La clase señala las propiedades que los hoteles que modelemos tendrán, pero no es ningún hotel específico. Para eso necesitamos las instancias.

Instancias
Mientras que las clases proveen la estructura, las instancias son los objetos reales que creamos en nuestro programa: un hotel llamado PlatziHotel o Hilton. Otra forma de pensarlo es que las clases son como un formulario y una vez que se llena cada copia del formulario tenemos las instancias que pertenecen a dicha clase. Cada copia puede tener datos distintos, al igual que cada instancia es distinta de las demás (aunque todas pertenecen a una misma clase).

Para definir una clase, simplemente utilizamos el keyword class. Por ejemplo:

class Hotel:
    pass
Una vez que tenemos una clase llamada Hotel podemos generar una instancia llamando al constructor de la clase.

hotel = Hotel()
Atributos de la instancia
Todas las clases crean objetos y todos los objetos tienen atributos. Utilizamos el método especial __init__ para definir el estado inicial de nuestra instancia. Recibe como primer parámetro obligatorio self (que es simplemente una referencia a la instancia).

class Hotel:
    
    def __init__(self, numero_maximo_de_huespedes, lugares_de_estacionamiento):
        self.numero_maximo_de_huespedes = numero_maximo_de_huespedes
        self.lugares_de_estacionamiento = lugares_de_estacionamiento
        self.huespedes = 0


hotel = Hotel(numero_maximo_de_huespedes=50, lugares_de_estacionamiento=20)
print(hotel.lugares_de_estacionamiento) # 20
Métodos de instancia
Mientras que los atributos de la instancia describen lo que representa el objeto, los métodos de instancia nos indican qué podemos hacer con las instancias de dicha clase y normalmente operan en los mencionados atributos. Los métodos son equivalentes a funciones dentro de la definición de la clase, pero todos reciben self como primer argumento.

class Hotel:

    ...

    def anadir_huespedes(self, cantidad_de_huespedes):
        self.huespedes += cantidad_de_huespedes

    def checkout(self, cantidad_de_huespedes):
        self.huespedes -= cantidad_de_huespedes

    def ocupacion_total(self):
        return self.huespedes


hotel = Hotel(50, 20)
hotel.anadir_huespedes(3)
hotel.checkout(1)
hotel.ocupacion_total() # 2
Ahora que ya sabemos qué son las clases y cómo las podemos utilizar en nuestros programas, platícanos qué clases te serían útiles para modelar en uno de tus programas.

***Clase 3 Tipos de datos abstractos y clases, Instancias***

- el constructor de python es: __init__
- en python cuando pierde las referencias, es decir, nadie está usando ese código por así decirlo el garbage collector lo elimina dentro de memoria
- Aunque en python no existe 
- Instancias:
    - Los atributos de clase nos permiten:
        - Representar datos
        - Procedimientos para interactuar con los mismos (métodos)
        - Mecanismos para esconder la representación interna
    - Se accede a los atributos con la notación de punto
    - Se pueden tener atributos privados, por convención comienzan con _
        - En algunos lenguajes se usa el keyword private para colocar como privado ese atributo
    
Datos abstractos o abstracción:

- Ventajas:
    - Decomposición
    - Abstracción
    - Encapsulación

- En python todo es un objeto y tiene un tipo.
    - Representación de datos y forma de interactuar con ellos

- Formas de interactuar con un objeto:
    - Creación - Crear
    - Manipulación - Manipular
    - Destrucción - Destruir

así se generan este tipo de datos abstractos:
usamos el keyword class que nos permite definir los tipos de datos abstractos luego se le da el nombre de la clase y en ocasiones se recibe una súper clase
después usamos el método def __init__ que se le conoce como constructor, en python siempre los metodos dentro de una clase empiezan con el primer parámetro que le llamamos self
se le pasan si se quiere otros métodos y, luego tenemos las expresiones de esa función o método
- las funciones que están dentro de las clases se convierten o se les pasa a llamar métodos
- el constructor es el primer método que se ejecuta cuándo se instancia una clase
- las variables son nombres que apuntan a memoria
- Ejemplo:
    - class Persona:
        def __init__(self, nombre, edad):
            self.nombre = nombre
            self.edad = edad
        
        def saluda(self, otra_persona):
            return f'Hola {otra_persona.nombre}, mi nombre es: {self.nombre}

- class es una clase
- def es una función, pero dentro de un class es un metodo, por lo tanto en nuestro ejemplo es un método.
- constructor es el primer método que se ejecuta
- instancia es lo que esta dentro de un método, después de self. Ejm.: (self, otra_coordenada).

***Clase 4 Decomposición***

- Partir un problema en problemas más pequeños
- Las clases permiten crear mayores abstracciones en forma de componentes
- Cada clase se encarga de una parte del problema y el programa se vuelve más fácil de mantener

- Cuando por ejemplo le pasamos a una función un parametro con valor ya asignado por así decirlo a este tipo de parámetro se le llama
default keyword o parámetro por defecto:
por ejemplo:
    - tipo="gasolina"
        def __init__(self, cilindros, tipo="gasolina"):
y aunque sea por defecto significa que si queremos lo específicamos, si no, no

***Clase 5 Abstracción***

Esto lo leí en internet y lo que entendí de la abstracción es:
    Es una clase abstracta sobre la cual no se pueden crear modelos concretos, y con esta no se pueden instanciar objetos, de todos modos, 
    tiene características específicas y funcionalidades de objeto con lo cual se puede distinguir del resto de tipos de objetos 

- Enfocarnos en la información relevante
- Separar la información central de los detalles secundarios
    - Separa la información relevante de la no relevante
- Podemos utilizar variables y métodos(privados o públicos)

***Clase 6 Funciones: base de los decoradores***

***Clase 7 Setters, getters y decorador property***

***Clase 8 Encapsulación, getters and setters***

***Clase 9 Herencia***

***Clase 10 Polimorfismo***

Módulo Complejidad algorítmica

***Clase 11 Introducción a la complejidad algorítmica***

***Clase 12 Conteo abstracto de operación***

***Clase 13 Notación asintótica***

***Clase 14 Clases de complejidad algorítmica***

Módulo Algoritmos de búsqueda y ordenación

***Clase 15 Búsqueda lineal***

***Clase 16 Búsqueda binaria***

***Clase 17 Ordenamiento de burbuja***

***Clase 18 Ordenamiento por inserción***

***Clase 19 Ordenamiento por mezcla***

Módulo Ambientes virtuales

***Clase 20 Ambientes virtuales***


Módulo Graficado

***Clase 21 ¿Por qué graficar?***

***Clase 22 Graficado simple***

Módulo Algoritmos de optimización

***Clase 23 Introducción a la optimización***

***Clase 24 El problema del morral***

***Clase 25 Conclusiones***